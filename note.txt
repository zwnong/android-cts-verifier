
--------------------------记事本--------------------------
|                                                                 |
|                       日常学习记录                      |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv 


--------------------------WTWD-----------------------------
|                                                         |
|                       waterworld                           |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
cts_verifier:
Device Owner Test 设置设备admin命令：
adb shell dpm set-device-owner com.android.cts.emptydeviceowner/.EmptyDeviceAdmin
报错：java.lang.IllegalStateException: Trying to set the device owner, but device owner is already set.
解决方案：移除admin----》adb shell dpm remove-active-admin  'com.android.cts.emptydeviceowner/.EmptyDeviceAdmin'


概率性已解决问题处理方法：严重问题一周三个版本，每个版本验证30次或者30min。普通问题一周三个版本，20次或者15min。

***************   DTMF  （双音多频）
	通话中 按键
	是一种在语音信道用音调来表示数字的方法  可以用来模拟话音信道传输信令 
	高群四个音  低群四个音  类（嘟滴答）  

运营商不支持混合VOLTE视频通话

*******************ESRVCC（Single Radio Voice Call Continuity）
发生 ESRVCC==中断volte
是3GPP提出的一种VoLTE语音业务连续性方案，主要是为了解决当单射频UE 在LTE/Pre-LTE 网络
和2G/3G CS 网络之间移动时，如何保证语音呼叫连续性的问题，即保证单射频UE 
在IMS 控制的VoIP 语音和CS 域语音之间的平滑切换。

2019/11/7
1移动3g案例  暂无移动3g网络
2物联卡、呼叫限制卡、移动会议卡案例、暂无测试卡
3三个运营商vilte互通案例，运营商不支持互通
4支持联通vilte 三星、MTK平台案例，暂无支持联通vilte三星、MTK平台手机

 1A1H  一通在通话  一通在等待
 
--------------------------ADB-----------------------------
|                                                         |
|                       adb小结                           |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv 
 
adb devices
adb root
adb remount 重新挂载系统分区，是系统分区重新可写
adb disable-verity 解锁system分区
adb shell screenrecord --time-limit 100
fastboot模式:adb reboot bootloader
 
# 启动app的某一个activity
adb shell am start -n packagName/.Ativity

----------------------------BAT---------------------------
|                                                         |
|                          bat小结                        |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv 

ping 127.0.0.1 -n 5000>nul 延迟五分钟后执行下一条命令
查找端口号：
netstat -aon | findstr "端口号"

tasklist | findstr "进程号"

rem 根据当前日期获取，年月日串
set yyyy=%date:~,4%
set mm=%date:~5,2%
set day=%date:~8,2% 
set "YYYYmmdd=%yyyy%%mm%%day%"
rem 把年月日串中的空格替换为0
set "YYYYmmdd=%YYYYmmdd: =0%"
echo "YYYYmmdd%YYYYmmdd%YYYYmmdd"
rem 根据当前时间获取，时分秒串
set hh=%time:~0,2%
set mi=%time:~3,2%
set ss=%time:~6,2% 
set "hhmiss=%hh%%mi%%ss%"
set "hhmiss=%hhmiss: =0%"
echo "hhmiss%Time%hhmiss"
echo %hhmiss%
rem 把时间串中的:替换为0
set "hhmiss=%hhmiss::=0%"
rem 把时间串中的空格替换为0
set "hhmiss=%hhmiss: =0%"
rem 根据日期时间生成文件名称，中间以HH区分日期和时间部分
set "filename=%YYYYmmdd%HH%hhmiss%.rar"
echo %filename%
pause 
 
连接特定的 DNS 后缀: meizu.com
描述: Intel(R) Ethernet Connection I217-LM
物理地址: ?64-00-6A-76-D7-AB
已启用 DHCP: 是
IPv4 地址: 172.16.141.84
IPv4 子网掩码: 255.255.254.0
获得租约的时间: 2019年11月13日 18:33:08
租约过期的时间: 2019年11月20日 17:33:58
IPv4 默认网关: 172.16.140.1
IPv4 DHCP 服务器: 172.16.1.199
IPv4 DNS 服务器: 172.16.80.104, 172.16.80.105
IPv4 WINS 服务器: 172.16.1.122, 172.16.1.121
已启用 NetBIOS over Tcpip: 是
连接-本地 IPv6 地址: fe80::90b8:325f:e0c0:d0c4%11
IPv6 默认网关: 
IPv6 DNS 服务器: 

接口地址：https://httpbin.ceshiren.com/#/

PLMN
Public Land Mobile Network -- 公共陆地移动(通信)网络 

在某个国家或地区，某个运营商的某种制式的蜂窝移动通信网络被称为PLMN。PLMN由政府或它所批准的经营者，
为公众提供陆地移动通信业务目的而建立和经营的网络。该网络可以与PSTN(Public Swithed Telephone Network，
公共交换电话网络)等其他通信网络互联互通，形成整个地区或国家规模的通信网。

在中国大陆地区，目前共有3张PLMN。即：
·中国移动的GSM/GPRS/EDGE网络
·中国联通的GSM/GPRS网络
·中国联通的CDMA-1X网络

 所谓的IP呼叫前缀通俗理解就是用户打长途电话时需要在呼叫号码前加拨的前缀号码,按照电信运营商以往规则,加拨IP呼叫前缀可以拥有一定的优惠额度。
电信运营商的IP呼叫前缀列举 1、中国移动:17951、12593; 2、中国联通:17911; 3、中国电信:17900...
IP呼叫前缀目前的存在形势 以往用户拨打长途电话的成本比较高,电信运营商会设置不同的IP



PATH=C:\windows\system32;C:\windows;C:\windows\System32\Wbem;C:\windows\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\ATI Technol
CE\Core-Static;D:\Android\sdk\tools;D:\Android\sdk\platform-tools;D:\Program Files\nodejs\;D:\Android\jdk\bin;D:\Android\jdk\jre\bin;D:\And
b;C:\Program Files (x86)\Qualcomm\QIKTool\1.0.85.1;C:\Program Files (x86)\Qualcomm\QXDM4;D:\Python\Scripts\;D:\Python\;C:\Users\v-nongzhong
\Roaming\npm

*******************************************************************
进入fastboot——输入fastboot flash modem + modem路径——fastboot reboot

(1)进入fastboot: 在关机的状态下按  音量下键 + 电源键
(2)输入fastboot flash modem  ：在手机与电脑连接之后，在cmd中输入fastboot flash modem  + NON-HLOS.bin       
(3)接着2 fastboot reboot ：在cmd中再次输入fastboot reboot即可

WAP PUSH是一种特殊格式的短信，而WAP就像互联网, 是一个内容丰富的网络, 用户如何找到自己喜欢的网站, 如何在网站中找到自己喜欢的
业务, 往往需要很长时间。
WAP PUSH 可以通过短信将链接到网站或企业, 到支持 WAP PUSH 功能的手机, 所以你只需要阅读这条短信 (服务信息), 打开短信中的链接,
 就可以直接访问企业。



双清---->  清除data 和 cache  相当于恢复出厂设置
   

	linux分区特点：
	root分区：  根分区
	data分区：  用于存储用户安装的app数据，  apk安装后所需要的文件都在这里
	dalvik cache:  安卓运用的是虚拟机制，先把软件放置在虚拟机中二次编码后才能给运行
	Ceche分区：  存储应用系统数据
	system分区：  整个系统
	user data分区：  用户数据分区，相当于内存卡

/////////////////////////////////////
	                                 ///
	留言录音：需开通语音信箱         //////////////////////////////
	
	MTK平台可以听到双方DTMF声；                                  ///
三星与高通平台只听得到自己的DTMF声音，听不到对端的（暂未实现功能）//
    
///////////////////////////////////////////////////////////////////

清除ddr数据 fastboot erase mdmddr

      移动         联通        电信
2G    GSM          GSM         CDMA 1X

3G    TD-SCDMA     WCDMA       CDMA2000

4G    TDD-LTE      TDD-LTE     TDD-LTE
                   FDD-LTE     TDD-LTE
	
	FDD:频分双工。单车道，不同时间允许走不同的方向
	TDD：双车道，一个车道只能走一个方向，双向互不干扰。


-------------------------
---------------------------
|                                                         |
|                       API小结                           |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv                                                                     

这是谷歌市场版的微信app，可以直接看到‘微信团队’的text、resource-id、class、content-desc属性值，
实际用find_element_by_android_uiautomator ()结合上面的四个方式来定位元素，这不太推荐的！！！，
因为单单使用那四个方式就完全可以实现定位。

(假设以下所有定位方式 都可以唯一定位某元素)

text属性值定位

find_element_by_android_uiautomator (‘new UiSelector().text(“XXXX”)’).click 正常匹配
find_element_by_android_uiautomator (‘new UiSelector().textContains(“XXXX”)’).click 模糊匹配
find_element_by_android_uiautomator (‘new UiSelector().textStartsWith(“XXXX”)’).click 开头匹配

resource-id、class、content-desc属性值

find_element_by_android_uiautomator (‘new UiSelector().resourceId(“XXXX”)’).click()
find_element_by_android_uiautomator (‘new UiSelector().className(“XXXX”)’).click()
find_element_by_android_uiautomator (‘new UiSelector().description(“XXXX”)’).click()

此外还有 正则匹配，这个需要配合正则表达式

组合定位
举例：class和resource-id 组合定位
weixin_str = ‘new UiSelector().resourceId(“xxxx”).className(“XXXX”)’

注意！！！class 和 id组合定位，但定位的这类元素 有可能会有很多！！！

driver.find_elements_by_android_uiautomator(‘new UiSelector().resourceId("%s").className("%s")’ % (self.tongxunlu_id, self.tongxunlu_class))[1].click()


函数：find_element_by_android_uiautomator
参数：uia_string
描述：通过元素名称查找一个android元素
用法：driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]')

函数：find_elements_by_android_uiautomator
参数：uia_string
描述：通过元素名称查找N个android元素
用法：driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]')

函数：find_element_by_accessibility_id 参数：id
描述：通过元素accessibility id查找一个元素
用法：driver.find_element_by_accessibility_id()

函数：find_elements_by_accessibility_id
参数：id
描述：通过元素accessibility id查找N个元素
用法：driver.find_elements_by_accessibility_id()

函数：create_web_element
参数：element_id
描述：使用指定的element id创建一个web元素

函数：scroll
参数：origin_el, destination_el
描述：从一个元素位置滚动到另一个元素位置
用法：driver.scroll(el1, el2)

函数：drag_and_drop
参数：origin_el, destination_el
描述：将一个元素从一个位置拖曳到另外一个位置
用法：driver.drag_and_drop(origin_el, destination_el)

函数：tap
参数：positions, duration
描述：点击屏幕指定位置，并在该位置停留duration指定的时长
用法：driver.tap([(100, 20), (100, 60), (100, 100)], 500)

函数：swipe
参数：start_x, start_y, end_x, end_y, duration=None
描述：从一个位置到另外一个位置滑动屏幕
用法：driver.swipe(100, 100, 100, 400)

函数：flick
参数：start_x, start_y, end_x, end_y
描述：从一个位置到另外一个位置快速滑动
用法：driver.flick(100, 100, 100, 400)

函数：pinch
参数：element=None, percent=200, steps=50
描述：捏
用法：driver.pinch(element)

函数：zoom
参数：element=None, percent=200, steps=50
描述：缩放屏幕
用法：driver.zoom(element)

函数：app_strings
参数：language=None, string_file=None
描述：获取应用字符串

函数：reset
参数：无
描述：重置设备当前的app
用法：driver.reset()

函数：hide_keyboard
参数：key_name=None, key=None, strategy=None
描述：隐藏键盘

函数：current_activity
参数：无
描述：获取设备当前app的activity
用法：driver.current_activity

函数：current_package
参数：无
描述：获取设备当前运行app的package
用法：driver.current_package

函数：set_value
参数：element, value
描述：给指定元素设置值
用法：driver.set_value(element, value)

函数：pull_file
参数：path
描述：从设备拉取文件
用法：driver.pull_file(path)

函数：push_file
参数：path, base64data
描述：以Base64编码方式向设备推送文件
用法：driver.push_file(path, base64data)

函数：background_app
参数：seconds
描述：将指定的app放在后端运行一段时间
用法：driver.background_app(seconds)

函数：is_app_installed
参数：bundle_id
描述：根据bundle id判断app是否已经安装
用法：driver.is_app_installed(bundle_id)

函数：install_app
参数：app_path
描述：安装app到设备
用法：driver.install_app(app_path)

函数：remove_app
参数：app_id
描述：卸载指定的app
用法：driver.remove_app(app_id)

函数：launch_app
参数：无
描述：启动desired capabilities指定的app
用法：driver.launch_app

函数：close_app
参数：无
描述：停止desired capabilities指定的app
用法：driver.close_app()

函数：start_activity
参数：app_package, app_activity, **opts
描述：启动指定参数的app, android专用

函数：lock
参数：seconds
描述：锁屏一段时间，ios专用
用法：driver.lock(5)

函数：shake
参数：无
描述：摇动设备
用法：driver.shake()

函数：open_notifications
参数：无
描述：打开通知，android专用，要求API level 18及以上
用法：driver.open_notifications()

函数：get_settings
参数：无
描述：获取当前appium服务端的设置
用法：driver.get_settings

函数：update_settings
参数：settings
描述：重设当前会话的设置,请参见 https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md

函数：device_time
参数：无
描述：返回设备的日期时间
用法: driver.device_time

                                                     元素操作

二、元素定位
 
1.格式：find_element_by_定位方式(value)
 
通过id定位
（取resource-id的值）：
driver.find_element_by_id("com.wuba.zhuanzhuan:id/azo")
也可以直接用id后面的内容driver.find_element_by_id("azo")
 
通过class_name定位
（取class的内容）
driver.find_element_by_class_name("android.widget.RelativeLayout")
 
通过xpath定位
（取xpath得内容）
driver.find_element_by_xpath("//android.widget.LinearLayout[1]/android.widget.XXX")
 
通过text定位
（需要使用uiautomator的定位方式，使用text的内容）
driver.find_elements_by_android_uiautomator("new UiSelector().text(\"+关注\")")
 
使用这里需要注意一下，通过text定位的结果是个list，不能直接click。所以如果要点击需要取数组的值，比如下面是点击找到的第一个元素
driver.find_elements_by_android_uiautomator("new UiSelector().text(\"+关注\")")[0].click()
 
通过css_selector定位（webview）
只适用于webview的html页面，继承自webdriver，与pc版本的UI测试一致
driver.find_element_by_css_selector()
 
通过link_text定位（webview）
只适用于webview容器中的html页面，继承自webdriver，与pc版本的UI测试一致
driver.find_element_by_link_text()
 
通过name定位
web view容器中的html页面可以用name定位，native并没有name属性
driver.find_element_by_name()
  
2.定位元素的另一种写法：find_element(by,value)
find_element_by_方式(value)实际调用的都是find_element(by,value)
需要导入这个包：from selenium.webdriver.common.by import By
 
例如：定位id为ag2的元素
方式一：driver.find_element_by_id("ag2”)
方式二：driver.find_element(By.ID,"ag2")
 
这个操作的好处是可以直接把操作的by和value放到一个元组里，然后调用通用方法来传参获得元素结果
cateid=(By.ID,"ag2")
driver.find_element(*cateid).click()
 
by的操作可以是：
By.ID   相当于by_id
By.CLASS_NAME  相当于by_class_name
By.XPATH   相当于by_xpath
By.NAME   相当于by_name
By.TAG_NAME   相当于by_tag_name
By.CSS_SELECTOR  相当于by_css_selector
By.LINK_TEXT  相当于by_link_text
 
 
3.find_elements_by_定位方式(value)返回元素数组
用法与find_element_by_方式(value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果
 
例如：通过class_name定位到多个元素，我想点击第一个元素
driver.find_elements_by_class_name("android.widget.RelativeLayout”)[0].click()
 
4.返回元素数组的另一种写法：find_elements(by,value)
用法与find_element(by,value)一致，但是返回一个数组。可以通过数组的索引来访问具体的某个结果
 
例如：通过class_name定位到多个元素，我想点击第一个元素
driver.find_elements(By.CLASS_NAME,"android.widget.RelativeLayout”)[0].click()
 
5.通过元素定位元素
可以先找到某个元素，然后再进一步定位元素
find_element_by_class_xpath(“xxx”).find_element_by_name(“yyy")
 
 
三、元素操作
 
找到元素后可以对元素进行的操作，例如上面讲的进一步定位元素
 
1.click()
//点击操作
也可以用tab实现点击操作
driver.find_element_by_id("com.wuba.zhuanzhuan:id/ae8").click()
 
2.clear()
//清空输入框内容
driver.find_element_by_id("com.wuba.zhuanzhuan:id/ij").clear()
 
3.send(xx)
//输入框内输入内容
driver.find_element_by_id("com.wuba.zhuanzhuan:id/ij").send_keys("test content")
 
4.text
//获得元素的text内容
print(driver.find_element_by_xpath(" //android.widget.LinearLayout[1]//xxx").text)
 
 
四、触摸操作
 
1.driver.tap([坐标]，持续点击时间)
除了定位到元素的点击外，也可以通过tab实现坐标的点击
driver.tap(driver.tap([(216,1776)],2))
 
2.TouchAction(driver)
TouchAction对象包含（tab）、press（短按）、move_to（滑动到某个坐标）等方法
 
通过TouchAction对象，添加tap、move_to等操作，然后perform()执行，可以实现解锁屏幕等功能
 
规范中的可用事件有：
 * 短按 (press)
 * 释放 (release)
 * 移动到 (moveTo)
 * 点击 (tap)
 * 等待 (wait)
 * 长按 (longPress)
 * 取消 (cancel)
 * 执行 (perform)
 
 例如：一个多次滑屏的例子：
action=TouchAction(driver)
action.press(x=220,y=700).move_to(x=840, y=700).move_to(x=220, y=1530).move_to(x=840, y=1530).release().perform()
可以通过wait()等待操作

3.MultiAction()//多点触控
通过MultiAction().add()添加多个TouchAction操作，最后调用perform()一起执行这些操作
action0 = TouchAction().tap(el)
action1 = TouchAction().tap(el)
MultiAction().add(action0).add(action1).perform()
 
4.driver.swipe(x1, y1, x2, y2,duration)  
//从坐标(x1,x2)滑动到坐标(x2,y2)，duration非必填项，滑动时间
（滑动的坐标不能超过屏幕的宽高）
可以通过【driver.get_window_size()】命令获得窗口高和宽，结果为{'width': 1080, 'height': 1776}
 
一个鼠标向上下左右活动的例子如下：
#获得屏幕大小宽和高
def getSize(driver):
    x = driver.get_window_size()['width']
    y = driver.get_window_size()['height']
    return (x, y)

#屏幕向上滑动
def swipeUp(driver,t=1000):
    l = getSize(driver)
    x1 = int(l[0] * 0.5)    #x坐标
    y1 = int(l[1] * 0.75)   #起始y坐标
    y2 = int(l[1] * 0.25)   #终点y坐标
    driver.swipe(x1, y1, x1, y2,t)

#屏幕向下滑动
def swipeDown(driver,t=1000):
    l = getSize(driver)
    x1 = int(l[0] * 0.5)  #x坐标
    y1 = int(l[1] * 0.25)   #起始y坐标
    y2 = int(l[1] * 0.75)   #终点y坐标
    driver.swipe(x1, y1, x1, y2,t)
#屏幕向左滑动
def swipLeft(driver,t):
    l=getSize(driver)
    x1=int(l[0]*0.75)
    y1=int(l[1]*0.5)
    x2=int(l[0]*0.05)
    driver.swipe(x1,y1,x2,y1,t)
#屏幕向右滑动
def swipRight(driver,t=1000):
    l=getSize(driver)
    x1=int(l[0]*0.05)
    y1=int(l[1]*0.5)
    x2=int(l[0]*0.75)
    driver.swipe(x1,y1,x2,y1,t)
 
#调用向下滑动的方法
swipeDown(driver)

五、系统按键事件
 
 press_keycode(AndroidKeyCode)//发送按键事件
例如：点击home键，home键的KeyCode是3
driver.press_keycode(3)
 
键名                  描述       键值
KEYCODE_CALL        拨号键     5
KEYCODE_ENDCALL     挂机键     6
KEYCODE_HOME        按键Home      3
KEYCODE_MENU        菜单键     82
KEYCODE_BACK        返回键     4
KEYCODE_SEARCH      搜索键     84
KEYCODE_CAMERA      拍照键     27
KEYCODE_FOCUS       拍照对焦键   80
KEYCODE_POWER       电源键     26
KEYCODE_NOTIFICATION 通知键        83
KEYCODE_MUTE        话筒静音键   91
KEYCODE_VOLUME_MUTE 扬声器静音键  164
KEYCODE_VOLUME_UP   音量增加键   24
KEYCODE_VOLUME_DOWN 音量减小键   25
 
 
 六、driver的一些比较重要操作
 
 截屏
 
driver.get_screenshot_as_file('./images/login.png')
 
1.reset()
//重置app
这时候driver会重置，相当于卸载重装应用。所以本地缓存会失效
driver.reset()
 
2.start_activity(包名,activity名)
//启动app的某一个activity
例如：driver.start_activity("com.wuba.zhuanzhuan","./presentation.view.activity.LaunchActivity")
 
启动一个activity，这个activity必须是AndroidManifest.xml中有intent-filter的activity
<intent-filter>
    <action android:name="android.intent.action.MAIN"/>
   <category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
 
这种启动activity和driver的reset()不同的是
 
3.contexts
//获得所有contexts
driver.contexts
 
结果如下：
['NATIVE_APP', 'WEBVIEW_com.android.browser']
 
NATIVE_APP：native的context
WEBVIEW_com.android.browser：webview的context，存放html的容器
 
4.current_context
//查看当前的context
driver.current_context
 
5.switch_to.context(context名)
//切换context
driver.switch_to.context("WEBVIEW_com.wuba.zhuanzhuan")
 
NATIVE时不能定位WEBVIEW的内容，在WEBVIEW的context时不能定位NATIVE的内容。
所以需要切换到对应的context中去进行操作
 
6.setNetworkConnection(bitmask掩码)
//设置网络类型
例如：设置网络类型为只开wifi
driver.set_network_connection(2)
 
网络的bitmask掩码如下：
| 值 (别名)           | 数据连接 | Wifi 连接 | 飞行模式 |
| ------------------ | ---- | ---- | ------------- |
| 0 (什么都没有)       | 0    | 0    | 0 |
| 1 (飞行模式)         | 0    | 0    | 1 |
| 2 (只有Wifi)         | 0    | 1    | 0 |
| 4 (只有数据连接)     | 1    | 0    | 0 |
| 6 (开启所有网络)     | 1    | 1    | 0 |

7.scroll(起始元素，结束元素)
driver.scroll(origin_el,destination_el)
 
8.获得当前页面的所有元素
driver.page_source
 
这可以用来判断元素是否存在，例如（assert "发布成功" in driver.page_source）
 
9.补充一些driver启动时可能用到的项
其实这些在上一篇启动里都有介绍，但是有些可能大家没注意到的点再列一下。这些点也是我在测试中实际遇到的点
 
autoLaunch ：Appium是否要自动启动或安装app，默认true
desired_caps['autoLaunch'] = 'false'
有的时候我不想让appium每次都启动app，想自己去启动activity，那这个项这时就可以起作用了
 
noReset：在会话前是否重置app状态。默认是false
desired_caps['noReset'] = 'true'
 
newCommandTimeout：设置未接收到新命令的超时时间，默认60s
如果60s内没有接收到新命令，appium会自动断开连接，如果我需要很长时间做driver之外的操作，可能延长接收新命令的超时时间
desired_caps["newCommandTimeout"]=1800




------------实例：----------

   
#定义的点击“取消”按钮方法
def check_cancelBtn():
    print('check cancelBtn')

    try:
        cancelBtn = driver.find_element_by_id('android:id/button2')
    except NoSuchElementException:
        print('no cancelBtn')
    else:
        cancelBtn.click()

#定义的点击“跳过”按钮方法
def check_skipBtn():
    print('check skipBtn')

    try:
        skipBtn = driver.find_element_by_id('com.tal.kaoyan:id/tv_skip')
    except NoSuchElementException:
        print('no skipBtn')
    else:
        skipBtn.click()


niansi
appium 模拟实现物理按键点击
appium自动化测试中，当确认，搜索，返回等按键通过定位点击不好实现的时候，可以借助物理按键来实现。
appium支持以下物理按键模拟:

电话键



KEYCODE_CALL 拨号键 5
KEYCODE_ENDCALL 挂机键 6
KEYCODE_HOME 按键Home 3
KEYCODE_MENU 菜单键 82
KEYCODE_BACK 返回键 4
KEYCODE_SEARCH 搜索键 84
KEYCODE_CAMERA 拍照键 27
KEYCODE_FOCUS 拍照对焦键 80
KEYCODE_POWER 电源键 26
KEYCODE_NOTIFICATION 通知键 83
KEYCODE_MUTE 话筒静音键 91
KEYCODE_VOLUME_MUTE 扬声器静音键 164
KEYCODE_VOLUME_UP 音量增加键 24
KEYCODE_VOLUME_DOWN 音量减小键 25

控制键

KEYCODE_ENTER 回车键 66
KEYCODE_ESCAPE ESC键 111
KEYCODE_DPAD_CENTER 导航键 确定键 23
KEYCODE_DPAD_UP 导航键 向上 19
KEYCODE_DPAD_DOWN 导航键 向下 20
KEYCODE_DPAD_LEFT 导航键 向左 21
KEYCODE_DPAD_RIGHT 导航键 向右 22
KEYCODE_MOVE_HOME 光标移动到开始键 122
KEYCODE_MOVE_END 光标移动到末尾键 123
KEYCODE_PAGE_UP 向上翻页键 92
KEYCODE_PAGE_DOWN 向下翻页键 93
KEYCODE_DEL 退格键 67
KEYCODE_FORWARD_DEL 删除键 112
KEYCODE_INSERT 插入键 124
KEYCODE_TAB Tab键 61
KEYCODE_NUM_LOCK 小键盘锁 143
KEYCODE_CAPS_LOCK 大写锁定键 115
KEYCODE_BREAK Break/Pause键 121
KEYCODE_SCROLL_LOCK 滚动锁定键 116
KEYCODE_ZOOM_IN 放大键 168
KEYCODE_ZOOM_OUT 缩小键 169

组合键

KEYCODE_ALT_LEFT Alt+Left
KEYCODE_ALT_RIGHT Alt+Right
KEYCODE_CTRL_LEFT Control+Left
KEYCODE_CTRL_RIGHT Control+Right
KEYCODE_SHIFT_LEFT Shift+Left
KEYCODE_SHIFT_RIGHT Shift+Right

基本

KEYCODE_0 按键’0’ 7
KEYCODE_1 按键’1’ 8
KEYCODE_2 按键’2’ 9
KEYCODE_3 按键’3’ 10
KEYCODE_4 按键’4’ 11
KEYCODE_5 按键’5’ 12
KEYCODE_6 按键’6’ 13
KEYCODE_7 按键’7’ 14
KEYCODE_8 按键’8’ 15
KEYCODE_9 按键’9’ 16
KEYCODE_A 按键’A’ 29
KEYCODE_B 按键’B’ 30
KEYCODE_C 按键’C’ 31
KEYCODE_D 按键’D’ 32
KEYCODE_E 按键’E’ 33
KEYCODE_F 按键’F’ 34
KEYCODE_G 按键’G’ 35
KEYCODE_H 按键’H’ 36
KEYCODE_I 按键’I’ 37
KEYCODE_J 按键’J’ 38
KEYCODE_K 按键’K’ 39
KEYCODE_L 按键’L’ 40
KEYCODE_M 按键’M’ 41
KEYCODE_N 按键’N’ 42
KEYCODE_O 按键’O’ 43
KEYCODE_P 按键’P’ 44
KEYCODE_Q 按键’Q’ 45
KEYCODE_R 按键’R’ 46
KEYCODE_S 按键’S’ 47
KEYCODE_T 按键’T’ 48
KEYCODE_U 按键’U’ 49
KEYCODE_V 按键’V’ 50
KEYCODE_W 按键’W’ 51
KEYCODE_X 按键’X’ 52
KEYCODE_Y 按键’Y’ 53
KEYCODE_Z 按键’Z’ 54

使用时，python中可以通过driver.press_keycode(#按键数字代号)来实现
亲测，在python2.7的环境中可以使用，但是需要注意的是：连续多次使用的过程中需要间隔一段时间，防止执行太快导致不起作用

--------------------------python--------------------------
|                                                         |
|                       打包exe工具                       |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv 

Python 是一个脚本语言，被解释器解释执行。它的发布方式：

.py 文件：对于开源项目或者源码没那么重要的，直接提供源码，需要使用者自行安装 Python 并且安装依赖的各种库。（Python 官方的各种安装包就是这样做的）。
.pyc 文件：有些公司或个人因为机密或者各种原因，不愿意源码被运行者看到，可以使用 pyc 文件发布，pyc 文件是 Python 解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的 Python 和依赖库。
可执行文件：对于非码农用户或者一些小白用户，你让他装个 Python 同时还要折腾一堆依赖库，那简直是个灾难。对于此类用户，最简单的方式就是提供一个可执行文件，只需要把用法告诉他即可。比较麻烦的是需要针对不同平台需要打包不同的可执行文件（Windows, Linux, Mac,…）。
.py 和.pyc 都比较简单，Python 本身就可以搞定。将 Python 脚本打包成可执行文件有多种方式。

PyInstaller
安装 pyinstaller
对于那些网络比较稳定，能够流畅使用 pip 源地址的用户，直接下面的命令就可以搞定：

pip install pyinstaller
 

通常我们会下载源码包，然后进入包目录，执行下面的命令（需要安装 setuptools）：

python setup.py install
 

安装完后，检查安装成功与否：

pyinstaller --version
 

安装成功后，就可以使用下面的命令了：

pyinstaller : 打包可执行文件的主要命令，详细用法下面会介绍。
pyi-archive_viewer : 查看可执行包里面的文件列表。
pyi-bindepend : 查看可执行文件依赖的动态库（.so 或.dll 文件）
pyi-… : 等等。

使用 PyInstaller
        pyinstaller 的语法：pyinstaller [options] script [script…] | specfile

        最简单的用法，在和 myscript.py 同目录下执行命令：

         pyinstaller mycript.py

         然后会看到新增加了两个目录 build 和 dist，dist 下面的文件就是可以发布的可执行文件，对于上面的命令你会发现
		 dist 目录下面有一堆文件，各种都动态库文件和 myscrip 可执行文件。有时这样感觉比较麻烦，需要打包 dist 下面的
		 所有东西才能发布，万一丢掉一个动态库就无法运行了，好在 pyInstaller 支持单文件模式，只需要执行：

        pyinstaller -F mycript.py

        你会发现 dist 下面只有一个可执行文件，这个单文件就可以发布了，可以运行在你正在使用的操作系统类似的系统的下面。当然，pyinstaller 还有各种选项，有通用选项，如 -d 选项用于 debug。

        在执行 pyInstaller 命令的时候，会在和脚本相同目录下，生成一个.spec 文件，该文件会告诉 pyinstaller 如何处理你
		的所有脚本，同时包含了命令选项。一般我们不用去理会这个文件，若需要打包数据文件，或者给打包的二进制增加一些 
		Python 的运行时选项时…一些高级打包选项时，需要手动编辑.spec 文件。可以使用：

        pyi-makespec optionsscript [script …]

        创建一个.spec 文件，对于手动编辑的.spec 文件，我们可以使用下面任意一条命令：

        pyinstaller specfile

        pyi-build specfile

PyInstaller 原理简介
        PyInstaller 其实就是把 python 解析器和你自己的脚本打包成一个可执行的文件，和编译成真正的机器码完全是两回事，
		所以千万不要指望成打包成一个可执行文件会提高运行效率，相反可能会降低运行效率，好处就是在运行者的机器上不用安
		装 python 和你的脚本依赖的库。在 Linux 操作系统下，它主要用的 binutil 工具包里面的 ldd 和 objdump 命令。

        PyInstaller 输入你指定的的脚本，首先分析脚本所依赖的其他脚本，然后去查找，复制，把所有相关的脚本收集起来，
		包括 Python 解析器，然后把这些文件放在一个目录下，或者打包进一个可执行文件里面。

        可以直接发布输出的整个文件夹里面的文件，或者生成的可执行文件。你只需要告诉用户，你的应用 App 是自我包含的，
		不需要安装其他包，或某个版本的 Python，就可以直接运行了。

        需要注意的是，PyInstaller 打包的执行文件，只能在和打包机器系统同样的环境下。也就是说，不具备可移植性，若需
		要在不同系统上运行，就必须针对该平台进行打包。

实践问题
        pyinstaller 打包后的 exe 运行怎么去掉弹出的命令行提示窗口？

        1. 如果使用.spec 文件的话, 在该文件中找到 console=True 修改为 console=False

        2. 如果是直接指定 python 文件进行 pyinstaller 打包的话，需要添加—noconsole

        pyinstaller path\mycode.py–noconsole

        如果想只打包成一个 exe：

        pyinstaller -F path\mycode.py –noconsole（注意：noconsole前面必须是两个  -  -，一个 - 不起作用）

       或：

        pyinstaller -F -wpath\mycode.py

        更换最终 exe 生成路径

        在 cmd 中，一开始就要 cd D:\PythonEXE\ 切换到输出文件夹，然后在用上面的代码，说明：各个参数的作用，

        例子：pyinstaller -F -w -pD:\tmp\core-python\libs -i d:\tmp\main.ico main.py

        -F 表示生成单个可执行文件；

        -D  –onedir 创建一个目录，包含 exe 文件，但会依赖很多文件（默认选项）。

        -w 表示去掉控制台窗口，这在 GUI 界面时非常有用。不过如果是命令行程序的话那就把这个选项删除吧！；

        -c  –console, –nowindowed 使用控制台，无界面 (默认)；

        -p 表示你自己自定义需要加载的类路径，一般情况下用不到；

        -i 表示可执行文件的图标。



填充手机内存：adb shell dd if=/dev/zero of=sdcard/AA bs=1024000 count=1024
                        修改count大小的值，1G=1024，要填充多少自己计算


运行内存：系统有最小内存保护阈值，内存达到阈值之后系统会不断的GC释放内存

1G =10241

499216
----------------------*****************性能（内存*************---------------------------

largeHeap项检查     large== 巨大的  heap==堆
查看是否为false，  adb shell dempsys meninfo packagName  

1
、首先， Android 程序运行时会启动一个 dalivk 虚拟机，而虚拟机的运行时内存
一般由堆和栈两大部分构成， largeHeap 是限制每个应用申请的最大内堆存值。
2
、若应用使用了 largeHeap 则会请求系统为 Dalvik 虚拟机分配更大的内存空间，
这样就比标准应用申请了更多的内存空间。
3
、一个设备的内存是固定的，当我们使用了 largeHeap 之后就可以使我们的程序
内存增加，但这部分增加的内存有可能是源自被系统杀掉的后台程序。所以，使
用 largeHeap 理论上是有可能杀掉其他的程 序的。但它不需要权限，在
menifest.xml 中设置 Application 的该属性即可。

eg:

1 、 这个 属性 在 拿到测试机后，首先确认是否有，没有的话，请 联系 性能开发
加入。（ 例如 M18 X2 项目上开始是没有该属性的）

2 、 已知问题有图库、地图、游戏中心三个模块，均已申请不解决，不再重复
提交 bug 。
2-1
、图库模块由于有多个场景需要，需要开启 largeHeap #441567
2-2
、地图功能复杂， 需要占用比较高的系统资源，申请开启 largeHeap
#675342
3 、游戏中心由于使用直播，申请 largeheap --#554180

====================***********海外组*************============


USAT-USIM Application Toolkit, USIM应用工具箱。

PSTN ，中文名称公共交换电话网络

中国移动预置DM业务：
增强售后服务，简称DM。定义为：中国移动推出的为用户提供终端远程参数设置和软件版本升级的一项服务。
使用于中国移动各品牌不含TD
用户只要使用具有增强售后服务功能的手机，无需定购，即可使用增强售后服务。
DM业务不向用户收取通信费和信息费。如果处在国际及港澳台漫游状态，按照现行资费标准计收GPRS流量费。
你可以拨打10086，提供需要配置的移动电话号码及手机厂商，手机型号。只要你的手机支持，他们就就会给你发。

NFC:
NFC即近场通信（Near Field Communication），是一种短距离的高频无线通信技术，
使用NFC技术的设备（如手机）可以在彼此靠近的情况下进行数据交换。
这种新兴技术由非接触式射频识别（RFID）及互连互通技术整合演变而来。
它通过在单一芯片上集成感应式读卡器、感应式卡片和点对点通信的功能，
利用移动终端实现移动支付、电子票务、门禁、移动身份识别、防伪等应用。

pyinstaller --onefile --windowed --icon="路径" app.py
pip --default-timeout=1000 install 


18377183873

adb shell am start -n com.meizu.telephonyengineermode/com.meizu.telephonyengineermode.TelephonyEngineerMode 

adb shell setenforce 0

10.57.224.118

辉杰wifi账号密码：
t-v-liangjianpei@meizu.com  
密码：88825286aA

联通votle
发送--->DGVOTLE（开通），TDVOTLE（关闭） 到10010

locadLibrary:找不到指定的模块




--------------------------Uiautomator2 ------------------------
|                                                              |
|                                                              |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

二、uiautomatorviewer解决方法

1.截取uix文件
adb shell uiautomator dump /sdcard/sc.uix
adb pull /sdcard/sc.uix

注明：新手机地址改成：/data/local/tmp/**.uix
2.截取截图
adb shell screencap -p /sdcard/sc.png
adb pull /sdcard/sc.png?
3.打开sdk tools目录下的uiautomatorviewer.bat，导入li从机器获取的截图和资源文件

------------------------------

设备连接方法，有两种

1. 通过WiFi，假设设备IP 192.168.5.4和您的PC在同一网络中

import uiautomator2 as u2
 
d = u2.connect('192.168.5.4') # alias for u2.connect_wifi('192.168.5.4')
print(d.info)
2. 通过USB， 假设设备序列是123456789F（见adb devices）

import uiautomator2 as u2
 
d = u2.connect('123456789F') # alias for u2.connect_usb('123456789F')
print(d.info)
检查并维持设备端守护进程处于运行状态

d.healthcheck()
连接本地USB设备

需要设备曾经使用 python -m uiautomator2 init 初始化过

d = u2.connect_usb("{Your-Device-Serial}")
如何停用UiAutomator的守护程序?

1. 直接打开uiautomator app（init成功后，就会安装上的），点击关闭UIAutomator

2.  d.service("uiautomator").stop()

打开调试开关

>>> d.debug = True
>>> d.info
12:32:47.182 $ curl -X POST -d '{"jsonrpc": "2.0", "id": "b80d3a488580be1f3e9cb3e926175310", "method": "deviceInfo", "params": {}}' 'http://127.0.0.1:54179/jsonrpc/0'
12:32:47.225 Response >>>
{"jsonrpc":"2.0","id":"b80d3a488580be1f3e9cb3e926175310","result":{"currentPackageName":"com.android.mms","displayHeight":1920,"displayRotation":0,"displaySizeDpX":360,"displaySizeDpY":640,"displayWidth":1080,"productName"
:"odin","screenOn":true,"sdkInt":25,"naturalOrientation":true}}
<<< END
安装应用，只能从URL安装
d.app_install（' http://some-domain.com/some.apk '）
安装应用

d.app_start（“ com.example.hello_world ”）＃ start包名称
停止应用

＃相当于`am force-stop`，因此你可能丢失数据 
d.app_stop（ “ com.example.hello_world ”） 
＃相当于`pm clear` 
d.app_clear（ ' com.example.hello_world '）
推送和拉取文件

把文件推送到设备
# push to a folder
d.push("foo.txt", "/sdcard/")
# push and rename
d.push("foo.txt", "/sdcard/bar.txt")
# push fileobj
with open("foo.txt", 'rb') as f:
    d.push(f, "/sdcard/")
# push and change file access mode
d.push("foo.sh", "/data/local/tmp/", mode=0o755)
从设备中提取文件
d.pull("/sdcard/tmp.txt", "tmp.txt")
 
# FileNotFoundError will raise if the file is not found on the device
d.pull("/sdcard/some-file-not-exists.txt", "tmp.txt")
跳过弹窗，禁止弹窗
d.disable_popups（） ＃自动跳过弹出窗口 
d.disable_popups（假）＃禁用自动跳过弹出窗口
Session

Session represent an app lifestyle. 可用于启动应用，检测应用崩溃

启动应用
sess = d.session（“ com.netease.cloudmusic ”）
Attach to the running app
sess = d.session（“ com.netease.cloudmusic ”，attach = True）
检测应用崩溃
# When app is still running
sess(text="Music").click() # operation goes normal
 
# If app crash or quit
sess(text="Music").click() # raise SessionBrokenError
# other function calls under session will raise SessionBrokenError too
# check if session is ok.
# Warning: function name may change in the future
sess.running() # True or False
检索设备信息

获取基本信息
d.info
以下是可能的输出：

{ 
    u'displayRotation': 0,
    u'displaySizeDpY': 640,
    u'displaySizeDpX': 360,
    u'currentPackageName': u'com.android.launcher',
    u'productName': u'takju',
    u'displayWidth': 720,
    u'sdkInt': 18,
    u'displayHeight': 1184,
    u'naturalOrientation': True
}
获取窗口大小
print(d.window_size())

# device upright output example: (1080, 1920)
# device horizontal output example: (1920, 1080)
获取最新的应用信息。对于某些Android设备，输出可能为空
print(d.current_app())

获取设备序列号
print(d.serial)
# output example: 74aAEDR428Z9
关键事件

打开/关闭屏幕
d.screen_on（）＃打开屏幕 
d.screen_off（）＃关闭屏幕

获取当前屏幕状态
d.info.get（' screenOn '）＃ require Android> = 4.4

Home / Back 按键操作
d.press("home") 
d.press("back")
d.press(0x07, 0x02) 

目前支持这些密钥名称：
home
back
left
right
up
down
center
menu
search
enter
delete ( or del)
recent (recent apps)
volume_up
volume_down
volume_mute
camera
power
 

解锁屏幕
d.unlock()

手势与设备的交互

点击屏幕
d.click（x，y）

双击
d.double_click（x，y）
d.double_click（X，Y，0.1）＃默认之间的两个点击持续时间为0.1秒

长按一下屏幕
d.long_click（x，y）
d.long_click（X，Y，0.5）＃长按0.5秒（默认）
Swipe
d.swipe(sx, sy, ex, ey)
d.swipe(sx, sy, ex, ey, 0.5) 

拖动
d.drag(sx, sy, ex, ey)
d.drag(sx, sy, ex, ey, 0.5) # Drag for 0.5s(default)

滑动点   多用于九宫格解锁，提前获取到每个点的相对坐标（这里支持百分比）
# swipe from point(x0, y0) to point(x1, y1) then to point(x2, y2)
# time will speed 0.2s bwtween two points
d.swipe((x0, y0), (x1, y1), (x2, y2), 0.2)
注意：单击，滑动，拖动操作支持百分比位置值。例：

d.long_click(0.5, 0.5) 表示长按屏幕中心

屏幕相关的

检索/设置设备方向     --可能的方向如下
natural or n
left or l
right or r
upsidedown or u (can not be set)

# 检索方向。输出可以是 "natural" or "left" or "right" or "upsidedown"
orientation = d.orientation
 
# WARNING: not pass testing in my TT-M1
# set orientation and freeze rotation.
# notes: setting "upsidedown" requires Android>=4.3.
d.set_orientation('l') # or "left"
d.set_orientation("l") # or "left"
d.set_orientation("r") # or "right"
d.set_orientation("n") # or "natural"
Freeze/Un-freeze rotation
# freeze rotation
d.freeze_rotation()
# un-freeze rotation
d.freeze_rotation(False)


截图
# 截取并保存到计算机上的文件，需要Android> = 4.2。
d.screenshot("home.jpg")
 
# 得到PIL.Image格式的图像. 但你必须先安装pillow
image = d.screenshot() # default format="pillow"
image.save("home.jpg") # or home.png. Currently, 只支持png and jpg格式的图像
 
# 得到OpenCV的格式图像。当然，你需要numpy和cv2安装第一个
import cv2
image = d.screenshot(format='opencv')
cv2.imwrite('home.jpg', image)
 
# 获取原始JPEG数据
imagebin = d.screenshot(format='raw')
open("some.jpg", "wb").write(imagebin)
Dump UI hierarchy
# get the UI hierarchy dump content (unicoded).
xml = d.dump_hierarchy()
打开通知或快速设置
d.open_notification（）
d.open_quick_settings（）
选择

class 0消息的用例 统一备注为：无支持Class 0消息的资源（公开版也无资源，暂未测试）

因为2091项目不支持BC0，（不支持电信2G和3G），所以不要提交电信2G和3G相关问题，请知悉。


 -------------------------DUMP-----------------------------------
 |                                                               |
 |                处理手机循环进dump的方法                       |
 |                                                               |
 vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
1-清理modem 

fastboot erase mdmddr
fastboot erase mdm1m9kefs1
fastboot erase mdm1m9kefs2
fastboot erase mdm1m9kefs3
fastboot reboot

2-导出dump

映射：mklink /d [本地文件路径][目标路径]
---------------------------------------------


----------------------------
|                          |
|***Batterystats日志*******|
|                          |
|**************************|
v--------------------------v

batterystats有两部分：

Statistics since last charge：     有用
Statistics since last unplugged：  


日志的抓取：

使用dumpsys命令
1、连接usb 进入shell模式
2、清除先前的日志： dumpsys batterystats --reset
3、测试结束后执行： dumpsys batterystats > /data/local/tmp/battery.log
4、导出battery.log： adb pull /data/loacal/tmp/battery.log 

获取基本信息：

Total run time:  总运行时间（包含充电） 
Time on battery: 电池状态下运行时间 
Screen on:       亮屏时间 
Time remaining:  剩余时间
Time on battery screen off（realtime）:灭屏时间 
Time on battery screen off（uptime）:  灭屏未待机时间 
Amount discharged while screen on:     亮屏耗电值 
Amount discharged while screen off:    灭屏耗电值
History中+top/-top:    应用到前台，和退到后台
根据以上信息，我们可以计算出相关耗电指标：
待机成功率 =（灭屏时间-灭屏未待机时间）/ 灭屏时间 
亮屏平均耗电 = 亮屏时间/亮屏耗电值 
灭屏平均耗电 = 灭屏时间/灭屏耗电值

1

---------------------------GIT----------------------------
|                                                         |
|                         github                          |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

托管到GitHub步骤：
   
   初始化仓库 git init
1、在github上创建项目

2、使用git clone https://github.com/zwnong/Python.git克隆到本地

3、编辑项目
.
4、git add . （将改动添加到暂存区）
   git add -A   文件夹下所有文件添加
5、git commit -m "提交说明"
对应：git commit -a -m "提交说明"
6、git push origin master 将本地更改推送到远程master分支。

7、创建分支：git branch dev
   进入分支：git checkout dev
   git add .    
   git commit -m "提交说明"
   远程与本地关联： git remote add origin
   查看分支：git branch -r  
   
   删除分支：git push origin :dev
8、已有本地分支，创建对应的远程分支：git push --set-upstream origin appium

9、已有远程分支，让他们建立track：

10、已有本地分支和远程分支，让他们建立track：git branch --set-upstream-to=origin/appium appium

11、要将本地push到远程，需要先设置邮箱和用户名
	 git config --global user.email "***@***"
	 git config --global user.name "***@***"

-----------------问题-----------：
$ git push -u origin master
To git@github.com:xxx/xxx.git
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'git@github.com:xxx/xxx.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.

原因：
GitHub远程仓库中的README.md文件不在本地仓库中。
解决方案：

$ git pull --rebase origin master
$ git push -u origin master

error: failed to push some refs to 'https://github.com/CrazyDony/text.git'

hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.

原因：
自己分支版本低于主版本

使用：git push -u origin master -f


原文链接：https://blog.csdn.net/u011471873/article/details/51462871



www.wowotech.net
https://github.com/MZCretin/Money
https://github.com/zwnong1/apps.git

URL管理器
URL下载器  urllib2
URL分析器  BeautifulSoup

com.android.systemui:id/mobile_volte


*********************BeautifulSoup*******************
https://cuiqingcai.com/1319.html

标签有两个重要的属性：

name：

#属性
attrs:

------------------------request------------------------------------

---------------------BeautifulSoup---------------------------------
常用正则表达式：
                               x = 'qqqabc1s21d1aabcc4s4da2saabcs5d6a5s'
1、点号 . : 匹配除\r\n之外的任何单个字符
        >>>print re.finfall('abc.', x)
		>>>['abc1', 'abcc', 'abcs'] 
		
2、星号 * ：匹配前一个字符任意次
        >>>print re.finfall('abc.', x)
		>>>['abc', 'abcc', 'abc']
		
3、问号 ？:匹配前一个字符0次或1次，与*号不同的是，其最多只匹配一次
        >>>print re.finfall('abc?', x)
		>>>['abc', 'abc', 'abc']
		
4、点星组合：贪婪算法，尽可能多的匹配数据
        >>>x = '<img src="https://tva1.sinaimg.cn/mw690/0062M7V0gy1g9xanbrrp3j31k02c0e3r.jpg" data-tag="bdshare">'
        >>>print(re.findall('http.*.jpg', x))
		>>>['https://tva1.sinaimg.cn/mw690/0062M7V0gy1g9xanbrrp3j31k02c0e3r.jpg']
        

------------------------unittest--------------------------
|                                                         |
|                   单元测试框架总结                      |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

一、unittest模块各个属性说明
unittest.TestCase:TestCase类，所有测试用例类继承的基本类
unittest.main():将一个单元模块变为可直接运行的测试脚本，main()方法使用TestLoader类来搜索所有包含在该模块中以“test”命名开头
                的测试方法，执行顺序：0-9；A-Z;a-z

TestCase属性：

说明：
>>>setUp():用于测试用例执行前的初始化工作，如需要访问数据库，可在这里先建立数据库连接
>>>tearDown():用于测试用例执行的善后工作，如关闭数据库，关闭wifi连接

------------*断言*-----------
|         assert*（）        |
-----------------------------
assertEqual(a,b [msg="测试失败时打印的信息"])：断言a,b是否相等,相等则用例通过
assertNotEqual(a，b [msg="测试失败时打印的信息"]) 
assertTrue(x, [msg="测试失败时打印的信息"])::断言x是否为True
assertFalse(x, [msg="测试失败时打印的信息"]):断言x是否为False
assertis(a,b [msg="测试失败时打印的信息"]):断言a是否是b,是则用例通过
assertNotIs(a,b [msg="测试失败时打印的信息"]):断言a是否是b，不是则用例通过
assertlsNone(x, [msg="测试失败时打印的信息"]):断言x是否为None,是则通过
asserttIn(a,b [msg="测试失败时打印的信息"]):断言a是否在b中，在则用例通过
asserttNotIn(a,b [msg="测试失败时打印的信息"]):断言a是否在b中，不在是则用例通过
assertIsInstance(a,b [msg="测试失败时打印的信息"]):断言a是否是b的实例，是则用例通过
assertNotIsInstance(a,b [msg="测试失败时打印的信息"]):断言a是否是b的实例，不是则用例通过




二、编写思路

#-----------------------------------------------------
# 1、设置编码utf-8，导入模块 import unittest
# coding:utf-8
# 2、注解：包括创建时间，创建人，项目名称
'''
Greated on  2020-01-13
@author: zwnong
projret: 编程思路
'''
import unittest

# 3、定义测试类：
class Test(unittest.TestCase):
    # 4、定义setUp(),用于测试前的初始化工作，注意 入参为“self”
	def setUp(self):
	    self.number = input('输入一个数字')
		self.number = int(self.number)
	
	# 5、定义tearDown(),用于用例执行后的善后工作，注意 入参为“self”
	def tearDown(self):
	    print(‘测试结束’)
		
    # 6、定义测试用例，以“test_”开头，注意 入参为“self”，使用unittest.TestCase下的各种断言
	def test_case01(self):
	    print(self.number)
		self.assertEqual(self.number, 10, msg="您输入的不是10")
		
	def test_case02():
	    print(self.number)
		self.assertEqual(self.number, 20, msg="您输入的不是20")
		
	# 7、跳过用例的方法
	@unittest.skip('暂时跳过用例3的测试')
	def test_Case03(self)
	    print(self.number)
		self.assertEqual(self.number, 30, msg="你输入的不是30")
		
# 8、如果直接运行该文件（if __name__ == "__main__":）,则执行以下语句
#   unittest.main()会搜索该模块下所有已test开头的测试用例并执行他们
if __name__ == "__main__":
	unittest.main()
	

***执行测试用例方案二：

# 先构建测试集
# 实例化测试套件
suite = unittest.TestSuite()

# 将测试用例加载到测试套件中
suite.addTest(Test('test_case02'))
suite.addTest(Test('test_case01'))

# 执行测试用例：
# 实例化TextTestRunner类：
runner = unittest.TextTestRunner()

# 使用run()运行套件
runner,run(suite)


----------------------HTMLTestRunner----------------------
|                                                         |
|                        测试报告                         |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

http://tungwaiyip.info/software/HTMLTestRunner.html

           ImportError: No module named 'StringIO'

下载HTMLTestRunner.py 原因是官网的是python2语法写的，看官手动把官网的HTMLTestRunner.py改成python3的语法：

第94行，将import StringIO修改成import io

第539行，将self.outputBuffer = StringIO.StringIO()修改成self.outputBuffer = io.StringIO()

第642行，将if not rmap.has_key(cls):修改成if not cls in rmap:

第766行，将uo = o.decode('latin-1')修改成uo = e

第775行，将ue = e.decode('latin-1')修改成ue = e

第631行，将print >> sys.stderr, '\nTime Elapsed: %s' % (self.stopTime-self.startTime)修改成
print(sys.stderr, '\nTime Elapsed: %s' % (self.stopTime-self.startTime))


#定义个报告存放的路径，支持相对路径
    file_path = "F:\\RobotTest\\result.html"
    file_result= open(file_path, 'wb')

    #定义测试报告
    runner = HTMLTestRunner.HTMLTestRunner(stream = file_result, title = u"百度搜索测试报告", 
	                                       description = u"用例执行情况")

    #运行测试用例
    runner.run(test)
    file_result.close()




-------------------------PageObject-----------------------
|                                                         |
|                       PO模型设计思想                    |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

      字面理解： 页面对象的意思
	  
即：页面元素的定位和页面元素的操作行为封装成一个page类，而测试用例中只包含业务逻辑代码

page的构成：
类的属性：各元素的定位
类的方法：各元素的操作方法

case中的测试用例：
用例中就是调用所需页面类中的方法根据业务逻辑组成测试用例

编写PO模型的六大原则：

   一.用公用方法代表UI所提供的功能
   二.方法应该返回其他的Page Object 或者返回用于断言的数据
   三.同样的行为不同的结果可以建模为不同的方法
   四.不要在方法上加断言
   五.不要暴露页面内部的元素给外部
   六.不需要建模UI内的所有元素
   
   
PO模式结构：
	
	projet
	  base
	    __init__.py
		base.py
		
	  page
	    __init__.py
		main_page.py
		*_page.py
		
	  testcases
	    __init__.py
		*_cases.py

模式分析：
	base类：经常需要调用的元素定位方法
	page(case)类：各个页面下的函数方法
	testcs类：各个测试用例集合


class Base():
    def __init__(self, driver):
        self.driver = driver

    def find_ID(self, ID):
        return self.driver.find_element_by_id(ID)

    def find_XPATH(self, XPATH):
        return self.driver.find_element_by_xpath(XPATH)
		
	
------------------------------------------------------------------------	
from projet.base.base import Base
from projet.page.search_page import SearchPage

class MainPage(Base):
    textview = "//android.widget.TextView[@text='同意']"
    search_input_box = "com.xueqiu.android:id/tv_search"

    def click_search(self):
        self.find_XPATH(self.textview).click()
        self.find_ID(self.search_input_box).click()
        return SearchPage(self.driver)



------------------------------------------------------------------------
from projet.base.base import Base

class SearchPage(Base):
    search_input = "com.xueqiu.android:id/search_input_text"
    alibaba = "//android.widget.TextView[@text='阿里巴巴']"
    price = "com.xueqiu.android:id/current_price"
    add_me = "com.xueqiu.android:id/follow_btn"

    def input_search_box(self, search_key):
        self.find_ID(self.search_input).send_keys(search_key)
        return self

    def click_search_key(self):
        self.find_XPATH(self.alibaba).click()
        return self

    def get_price(self):
        current_price = float(self.find_ID(self.price).text)
        return current_price

    def addseleciton(self):
        self.find_ID(self.add_me).click()
        return self

------------------------------------------------------------------------

from appium import webdriver
from projet.page.main_page import MainPage

class TestSearchFunc():
    def setup(self):
        desire_cap = {}
        desire_cap['platformName'] = 'Android'
        desire_cap['platformVersion'] = '5.1.1'
        desire_cap['deviceName'] = 'emulator-5554'
        desire_cap['appPackage'] = 'com.xueqiu.android'
        desire_cap['appActivity'] = 'view.WelcomeActivityAlias'
        self.driver = webdriver.Remote('http://127.0.0.1:4723/wd/hub', desire_cap)
        self.driver.implicitly_wait(10)

    def teardown(self):
        self.driver.quit()

    def test_search_01(self):
        mp = MainPage(self.driver)
        print(mp.click_search().input_search_box("alibaba").click_search_key().get_price())

    def test_search_02(self):
        mp = MainPage(self.driver)
        mp.click_search().input_search_box("alibaba").click_search_key().addseleciton()


------------------------------------------------------------------------

1、读取配置文件基础代码
	使用ConfigParser类中的get方法，然后读取到value
	
	conf=ConfigParser.ConfigParser()
	key1=conf.get("section","option") # 读取到第一个section的中的option值
	key2=conf.get("section2","option")# 读取到第二个section的中的option值
	读取配置文件代码封装
	
2、定位信息封装思路
	定位信息代码封装
	
3、分层思想

4、封装page层

5、封装handle层

6、封装business


信号强度对比：通讯性能所有TAB页的注网测试（除5G-SA）农忠文（一台测试机一台对比机）




-------------------------monkey-----------------------
|                                                         |
|                    Monkey使用实例                       |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

adb shell monkey -p com.meizu.filemanager -s 1000 --pct-touch 35 --pct-motion 25 --pct-appswitch 20 --pct-nav 10 --pct-majornav 10 --throttle 10 --monitor-native-crashes -v -v 10000 > data/momkeylog.txt


1. 执行Monkey命令：

adb shell monkey -p  package.name  -s 1000 --pct-touch 30  --pct-motion 25  --pct-appswitch 25  --pct-nav 10 --pct-majornav 5  
--throttle 1000  --monitor-native-crashes  -v -v 100000 >打印日志保存的完成路径（本机路径）

   实际测试中，需要根据待测包的实际使用情况， 确定命令中使用的具体参数。

本命令中参数设置思路：

（1）仅测试一个APP，故：设置参数  -p  package.name

（2）seed值，第一次运行可以不设置，设置目的：产生相同的序列，因上次运行后seed值是1000，为了复现问题，故：设置参数 -s 1000

（3）待测APP，常用操作：点触、滑动、系统按键（返回、HOME等）、键盘；

故：设置参数 --pct-touch 30  --pct-motion 25  --pct-appswitch 25 --pct-majornav 20
点触事件占30%，手势事件占比25%，Activity跳转事件占比25%，j基本导航时间占比10%，主导航事件占比10% 。

（4）设置各个操作的时延，可以根据实际点触使用时长设置；故：设置参数 --throttle 1000（将时延设置成1000毫秒）

（5）测试过程中，发生过本地代码导致的崩溃行为；故：设置参数 --monitor-native-crashes

（6）打印的日志等级，根据需要设置，故：参数设置 -v -v（1级）

（7）随机事件数，根据实际需要设置此数值，故：设置为 100000

（8）因测试目的是暴露APP崩溃或超时等问题，故未设置调试选项，如：--ignore-crashes、--ignore-timeouts 等。

 

2. Monkey运行中停止类型

    （1）自动停止

A.正常停止

 命令中设置的随机事件数执行完成，正常停止，报告中可以搜索到关键字：Finished。


B. 异常停止

1）如果限定了Monkey运行在一个或几个特定的包上，那么它会监测试图转到其它包的操作，并对其进行阻止。

2）如果应用程序崩溃或接收到任何失控异常，Monkey将停止并报错。

3）如果应用程序产生了应用程序不响应(application not responding)的错误，Monkey将会停止并报错。

    （2）手动停止

如果想中途暂停Monkey命令的执行，可以用如下命令：

  1）输入：adb shell， 进入shell模式；

  2）输入：ps | grep monkey，查看monkey的进程号；

  3）输入：kill -9 进程号；

  4）输入：exit，退出shell模式。

 

3. 报告分析

（1）打开日志文件，查找关键字：ANR（程序无响应）、CRASH（崩溃）、Exception（异常）、androidruntime、out of memory、null pointer，若存在，则说明发生异常，需要提交开发来核查。

（2）打开日志文件，查找关键字：Finished，若存在，则证明Monkey正常结束。

 

4. 若需核查，需提交给开发的内容

（1）Monkey的测试报告；

（2）被测设备的信息。


-------------------------selenium-----------------------
|                                                         |
|                                           |
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv


安装：pip install selenium

浏览器驱动：加载浏览器环境需要下载对应的浏览器驱动，此处选择 Chrome http://npm.taobao.org/mirrors/chromedriver/

将驱动文件放在浏览器安装目录中，并配置环境变量

# coding = utf-8

from selenium import webdriver

# 存储浏览器驱动路劲

path_browser_driver = r'D:\Google\Chrome\Application\chromedriver.exe'
driver = webdriver.Chrome(executable_path=path_browser_driver)
url = 'http://www.sogou.com/'
driver.get(url)


pycharm 切换 python3.9 报错 ‘HTMLParser‘ object has no attribute ‘unescape‘ 解决   https://blog.csdn.net/pythontide/article/details/109316457




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 